# :dna: Haplotype comparative genomics and high-depth dual-transcriptomics reveal genetic variation and pathogenic strategies of sugarcane smut

The following repository contains the workflow used in _"Haplotype comparative genomics and high-depth dual-transcriptomics reveal genetic variation and pathogenic strategies of sugarcane smut"_ by Vilanova and collaborators* (2025):

_Pedro Fernando Vilanova (PFV), Lucas Mitsuo Taniguti (LMT), Marcella Ferreira (MF), ThaÃ­s Carolina da Silva Dalâ€™Sasso (TCSDS), Gustavo Schiavone Crestana (GSC), LÃ¢ina da Silva de Oliveira (LSO), Renato Gustavo Hoffmann Bombardelli (RGHB), JoÃ£o Paulo Kitajima (JPK), Silvana Creste (SC), LuÃ­s Eduardo Aranha Camargo (LEAC), Marie-Anne Van Sluys (MAVS), Claudia Barros Monteiro-Vitorello (CMBV)._

The pipeline described in this GitHub involved the following steps:
1. Assembly of Nanopore reads into contigs with Flye and Canu.
2. Polishing with Medaka and Pilon to improve the assembly
3. Quality control of the assemblies with QUAST 
4. Evaluate assembly completeness with BUSCO
5. Synteny analysis with NUCmer and plotting with dotplotly
6. Gene annotation with FunGAP
7. Variant annotation with SNPeff and functional annotation with Blast2GO

# :bar_chart: DNA sequencing report and assembly

For our article, we sequenced the SSC04 (_MAT-1_) and SSC39 (_MAT-2_) haploid strains of _Sporisorium scitamineum_, using the ```FLO-MIN106``` flow cell type. For both sequencing runs, we used the R9 sequencing kit type ```SQK-LSK109```. For SSC04 (_MAT-1_) the flow cell ID was  ```FAL62188``` and for SSC39 (_MAT-2_) the flow cell ID was ```FAL62161```. 

## Basecalling
For the genome assemblies of this article, we used Guppy v. 6.4.6 (Oxford Nanopore Technologies) and it can be installed by accessing:

```https://community.nanoporetech.com/downloads```

>Note: By 2023, a new basecaller called Dorado has been implemented for ONT analysis, it wasn't available at the time of the current assemblies.

For basecalling, make sure to process it in a GPU machine with the following requeriments: 
1. Put all the ```.fast5``` raw sequencing files in a single folder called ```/fast5```.
2. The ```-s``` option needs to have as input the output path for the basecalled ```fastq.``` files.
3. We need to provide a model for Guppy to use in basecalling, it depends primarily on our flow cell technology, which was the R9 back in time, that's why we used ```dna_r9.4.1_450bps_sup.cfg```.
4. We also need to provide a chunk size number for Guppy, it will basically set the size of the chunks of data which are sent to the basecaller for analysis, we do this using the ```--chunk_size 1000``` command.
5. The next things need to be set to tune the GPU parameters, i.e. ```gpu_runners_per_device``` and ```--devide cuda:all:100%```, choose what's best for your machine.
6. Last but no least, an extremely important paremeter is the minimum quality score, i.e. the minimum acceptable qscore for a read to be filtered into the PASS folder.
> Note: We used a minimum Qscore of 7 back in time, because when using higher values (like 10), the number of reads would decrease significantly, so we chose to be in the middle path.

```
sudo guppy_basecaller -i /var/lib/minknow/data/39a_nati_sscitamineum_18_05/39a_nati_sscitamineum_18_05/20230518_1340_MN32147_FAL62161_4a6760c3/fast5 \
-s /var/lib/minknow/data/39a_nati_sscitamineum_18_05/39a_nati_sscitamineum_18_05/20230518_1340_MN32147_FAL62161_4a6760c3/fastq \
-c /opt/ont/guppy/data/dna_r9.4.1_450bps_sup.cfg \
--chunk_size 1000 \
--gpu_runners_per_device 4 \
--device cuda:all:100% \
--min_qscore 7
```

## Assessing read quality 
For assessing read quality, we used [MinIONQC](https://github.com/roblanf/minion_qc) written in R. According to the authors:
> MinIONQC gives you a range of diagnostic plots and data for quality control of sequencing data from Oxford Nanopore's MinION and PromethION sequencer.

We run MinIONQC in command line. The only necessary input file is the ```sequencing_summary.txt``` which is generated by Guppy after basecalling the ```.fast5``` files.

```
Rscript MinIONQC.R -i /home/pedro/ssc_04_b_29_03_23/20230329_1512_MN32147_FAL62188_d457662b/fastq_04B/sequencing_summary.txt
```

## Adapter trimming

After assessing read quality, we need to trim adapters from the sequencing reads, because they are artificial sequences that do not exist in the biological sequence of interest, we used ```Porechop v. 0.2.4```.

We only need as input the ```.fastq``` basecalled reads. 

```
porechop -i SSC04B_allreads_2023.fastq \
--check_reads 300000 \
--format fastq \
-o SSC04B_allreads_porechop.fastq
```

>Note: Porechop automatically identifies ONT adapters and trim them from our reads.

## ðŸ¥¼ Genome assembly

 Even though we assembled _S. scitamineum_ genomes during the year of 2023, we were only able to use Oxford Nanopore MinION reads from R9 flow cell technology. In March 2024, we sequenced each haploid of opposite mating-types of differente isolates from the fungus. In order to better assemble genomes with the new data, this report aims to describe the exploratory pipeline. 

 We selected few assemblers regarding long-read assemblers and hybrid assemblers, among them:
 
 **1. MaSuRCA**
 
 **2. SPAdes**
 
 **3. Unicycler**
 
 **4. Flye**
 
 **5. Canu**

MaSuRCA and SPAdes are both hybrid assemblers and we have chosen them specifically because they accept input from both ONT reads and Illumina reads. Otherwise, Flye and Canu are common long-read assemblers used in previous projects and exploratory assemblies. 

## :dna: MaSuRCA: A hybrid assembler ##
According to the authors of MaSuRCA software:

> Our method transforms large numbers of paired-end reads into a much smaller number of longer â€˜super-readsâ€™. The use of super-reads allows us to assemble combinations of Illumina reads of differing lengths together with longer reads from 454 and Sanger sequencing technologies, making it one of the few assemblers capable of handling such mixtures.

We:
1. Downloaded the latest distribution (v.4.1.1 when this report was written) from the [github release page](https://github.com/alekseyzimin/masurca/releases/download/v4.1.1/MaSuRCA-4.1.1.tar.gz).
2. Used ```tar -xzf``` to untar/unzip the file distribution
3. Inside the unzipped folder, we ran ```./install.sh```

According to the software authors, the above steps are sufficient to a complete configuration of all necessary dependencies and packages. It is necessary to note that, apparently, MaSuRCA will only work if installing ```numactl```, as follows:

```sudo apt-get update```

```sudo apt-get install numactl```

It is important to note that we used raw uncorrected reads for both Illumina and ONT reads. We made this choice because of the following instruction provided by the authors:

>IMPORTANT! **Avoid using third party tools to pre-process the Illumina data before providing it to MaSuRCA**, unless you are absolutely sure you know exactly what the preprocessing tool does. Do not do any trimming, cleaning or error correction. This will likely deteriorate the assembly.

Finally, below is the command we used to run the assembler:

```
/home/pedro/assemblies/MaSuRCA-4.1.1/bin/masurca -t 11 -i /home/pedro/assemblies/04B/raw/illumina/NGS767_2_SSC04B_S19_L001_R1001.fastq.gz,/home/pedro/assemblies/04B/raw/illumina/NGS767_2_SSC04B_S19_L001_R2_001.fastq.gz -r /home/pedro/assemblies/04B/raw/nanopore/SSC04B_allreads_2023.fastq.gz
```

The use of each parameter is described as follow:
1. ```-t``` number of threads to be used
 
2. ```-i``` input of Illumina reads
  
3. ```-r``` input of ONT reads

According to log, the software calculated an average PE read length of **242**, while choosing to use a kmer of **99**. The estimated genome size was **20.516.155 pb**, which is actually the genome size according to our previous knowledge. The software, apparently, correctly understood the **1 ploidy**, since we're assembling a haploid genome. 

>This command will run a hybrid assembly, **correcting Nanopore reads with Illumina data first**. Ilumina paired-end reads files must be fastq, can be gzipped, and Nanopore/PacBio data files for the -r option can be fasta or fastq and can be gzipped.

```
                                         Number of scaffolds         28
                                     Total size of scaffolds   20124895
                                            Longest scaffold    3182994
                                           Shortest scaffold      49423
                                 Number of scaffolds > 1K nt         28 100.0%
                                Number of scaffolds > 10K nt         28 100.0%
                               Number of scaffolds > 100K nt         24  85.7%
                                 Number of scaffolds > 1M nt          6  21.4%
                                Number of scaffolds > 10M nt          0   0.0%
                                          Mean scaffold size     718746
                                        Median scaffold size     657704
                                         N50 scaffold length     945175
                                          L50 scaffold count          7
                                         n90 scaffold length     556902
                                          L90 scaffold count         18
                                                 scaffold %A      22.50
                                                 scaffold %C      27.47
                                                 scaffold %G      27.51
                                                 scaffold %T      22.52
                                                 scaffold %N       0.00
                                         scaffold %non-ACGTN       0.00
                             Number of scaffold non-ACGTN nt          0

                Percentage of assembly in scaffolded contigs       0.0%
              Percentage of assembly in unscaffolded contigs     100.0%
                      Average number of contigs per scaffold        1.0
Average length of break (>25 Ns) between contigs in scaffold          0

                                           Number of contigs         28
                              Number of contigs in scaffolds          0
```

## :dna: SPAdes: A hybrid assembler ##
Just like MaSuRCA, we proceeded to test SPAdes, being a hybrid assembler as well. We chose this tool because according to the authors:

> SPAdesâ€”St. Petersburg genome Assemblerâ€”was originally developed for de novo assembly of genome sequencing data produced for cultivated microbial isolates and for single-cell genomic DNA sequencing. With time, the functionality of SPAdes was extended to enable assembly of IonTorrent data, as well as hybrid assembly from short and long reads (PacBio and Oxford Nanopore).

We installed the software as follows:

1. Download the SPAdes v.3.15.5 binary through:  ```wget https://github.com/ablab/spades/releases/download/v3.15.5/SPAdes-3.15.5-Linux.tar.gz```
2. Unzip the binary file through: ```tar -xzf SPAdes-3.15.5-Linux.tar.gz```

We proceeded to use the program by calling ```/media/hdzin/pedro/assembly/SPAdes-3.15.5-Linux/bin/spades.py```

Just as MaSuRCA, we did not previously filtered or trimmed the raw reads, since the authors state:

> PacBio CLR and Oxford Nanopore reads are used for hybrid assemblies (e.g. with Illumina or IonTorrent). **There is no need to pre-correct this kind of data.** SPAdes will use PacBio CLR and Oxford Nanopore reads for gap closure and repeat resolution.

We proceeded to the assembly. The following files were used as input for the SPAdes hybrid assembly:

1. ðŸ“‚ Illumina sequencing reads
4. ðŸ“‚ Oxford Nanopore MinION reads

We used the following code to proceed with the assembly:

```
/media/hdzin/pedro/assembly/SPAdes-3.15.5-Linux/bin/spades.py -1 /media/hdzin/pedro/Genomes_Illumina/NGS767_Claudia_Pedro-412581533/BCLConvert_03_16_2024_02_30_30Z-723878187/NGS767_2_SSC04B-ds.e41443545426483b9c820599b1897356/NGS767_2_SSC04B_S19_L001_R1_001.fastq.gz -2 /media/hdzin/pedro/Genomes_Illumina/NGS767_Claudia_Pedro-412581533/BCLConvert_03_16_2024_02_30_30Z-723878187/NGS767_2_SSC04B-ds.e41443545426483b9c820599b1897356/NGS767_2_SSC04B_S19_L001_R2_001.fastq.gz --nanopore /media/SSD1TB/pedro/dnaseq/04/mat_1/fastq/raw/SSC04B_allreads_raw.fastq.gz -o /media/hdzin/pedro/assembly/04B
```

Each parameter is described below:

1. ```-1``` the PE1 read pair of illumina reads
   
2. ```-2``` the PE2 read pair of illumina reads
   
3. ```--nanopore``` ONT reads

The assembly was successfull according to the log file:

```
 * Paths in the assembly graph corresponding to the contigs are in /media/hdzin/pedro/assembly/04B/contigs.paths
 * Paths in the assembly graph corresponding to the scaffolds are in /media/hdzin/pedro/assembly/04B/scaffolds.paths
 * Assembly graph is in /media/hdzin/pedro/assembly/04B/assembly_graph.fastg
 * Assembly graph in GFA format is in /media/hdzin/pedro/assembly/04B/assembly_graph_with_scaffolds.gfa

======= SPAdes pipeline finished.

SPAdes log can be found here: /media/hdzin/pedro/assembly/04B/spades.log

Thank you for using SPAdes!
```

The resulting assembly demonstrated to be quite fragmented, producing **470 contigs**, the smallest one with **218 pb**, and the largest **808.454 pb**

## :dna: Unicycler: hybrid assembler ##

According to the software authors:

>Unicycler is an assembly pipeline for **bacterial genomes**. It can assemble Illumina-only read sets where it functions as a SPAdes-optimiser. It can also assembly long-read-only sets (PacBio or Nanopore) where it runs a miniasm+Racon pipeline. For the best possible assemblies, give it both Illumina reads and long reads, and it will conduct a short-read-first hybrid assembly.

We used ```Unicycler v0.5.0```. The following files were used as input to Unicycler:
1. ðŸ“‚ ONT sequencing reads:.
2. ðŸ“‚ Illumina sequencing reads.

We used the following code to assemble the genome:

```
/home/program2/bin/Unicycler/0.5.0/bin/unicycler -1 /home/sporisor/dnaseq/illumina/Genomes_Illumina/NGS767_Claudia_Pedro-412581533/BCLConvert_03_16_2024_02_30_30Z-723878187/NGS767_2_SSC04B-ds.e41443545426483b9c820599b1897356/NGS767_2_SSC04B_S19_L001_R1_001.fastq.gz -2 /home/sporisor/dnaseq/illumina/Genomes_Illumina/NGS767_Claudia_Pedro-412581533/BCLConvert_03_16_2024_02_30_30Z-723878187/NGS767_2_SSC04B-ds.e41443545426483b9c820599b1897356/NGS767_2_SSC04B_S19_L001_R2_001.fastq.gz -l /home/sporisor/dnaseq/dnaseq/04/mat_1/fastq/raw/SSC04B_allreads_raw.fastq.gz -t 20 -o /home/sporisor/assemblies/unicycler
```

Unicycler produced **144 contigs**.

## :dna: Flye: long-reads assembler ##

According to the software authors:

>Flye is a de novo assembler for single-molecule sequencing reads, such as those produced by PacBio and Oxford Nanopore Technologies. It is designed for a wide range of datasets, from small bacterial projects to large mammalian-scale assemblies. The package represents a complete pipeline: it takes raw PacBio / ONT reads as input and outputs polished contigs. Flye also has a special mode for metagenome assembly.

We used ```Flye v.2.9.1-b1780```. The following files were used as input to Flye:

1. ðŸ“‚ ONT sequencing reads.

We used the following code to assemble the genome, using raw ONT reads:

```
flye --nano-raw /home/pedro/assemblies/04B/raw/nanopore/SSC04B_allreads_2023.fastq.gz -g 20m -t 10 -o ./
```

1. The ```--nano-raw``` parameter is essential, because it assumes as input ONT regular reads, pre-Guppy5 (<20% error)
2. The ```-g``` parameter sets the estimated genome size, and I used 20 million bases as the expected size.

The assembly produced **30 contigs**.

## :dna: Canu: long-reads assembler ##

According to the software authors:

>Canu is a fork of the Celera Assembler, designed for high-noise single-molecule sequencing (such as the PacBio RS II/Sequel or Oxford Nanopore MinION).
Canu is a hierarchical assembly pipeline which runs in four steps:
>1. Detect overlaps in high-noise sequences using MHAP
>2. Generate corrected sequence consensus
>3. Trim corrected sequences
>4. Assemble trimmed corrected sequences

We used ```Canu v.2.2``` . The following files were used as input to Canu:

1. ðŸ“‚ ONT sequencing reads.

```
./canu -p SSC04B genomeSize=20M -nanopore-raw /home/pedro/assemblies/04B/raw/nanopore/SSC04B_allreads_2023.fastq.gz -d /home/pedro/assemblies/04B/assembly/canu/
```

1. Similar to Flye, we used ```-nanopore-raw``` to use as input raw ONT reads.
2. The expected genome size is given to the parameter ```genomeSize```.

It is important to note a few things about Canu default options, because we used default:
1. The default ```correctedErrorRate``` is 0.144 for Nanopore reads.
2. The default ```rawErrorRate ``` is 0.500 for Nanopore reads.
3. The default ```minReadLength``` is 1000.
4. The default ```minOverlapLength``` is 500.

The Canu assembly, like Flye, generated **30 contigs**

# Evaluating the assembly: which one is the best?

After we assembled one genome using the same data for each one of the above described softwares, we proceeded to use ```QUAST v5.0.2``` software, and used it in a conda environment. We provided as input all five genomes (each one built by a different assembler) and used the option ```--fungus```, because according to instructions:

> By default, QUAST assumes that a genome is circular and correctly processes its linear representation. This options indicates that the genome is not circular.

It is important to remember that we provided the reference genome ```.fasta``` file to obtain statistics regarding Taniguti et al. (2015) reference
1. :page_facing_up: Genome reference
2. :page_facing_up: Canu assembly
3. :page_facing_up: Flye assembly
4. :page_facing_up: SPAdes assembly
5. :page_facing_up: MaSuRCA assembly
6. :page_facing_up: Unicycler assembly


```
quast.py --fungus -r /home/thais/Ssci_references/39B/NCBI_Ssci_genome.fa --threads 10 -o ./ /home/pedro/assemblies/04B/assembly/canu/SSC04B_canu.fasta /home/pedro/assemblies/04B/assembly/flye/SSC04B_flye.fasta /home/pedro/assemblies/04B/assembly/spades/SSC04B_spades.fasta /home/pedro/assemblies/04B/assembly/masurca/CA.mr.99.17.15.0.02/SSC04B_masurca.fasta /home/pedro/assemblies/04B/assembly/unicycler/SSC04B_unicycler.fasta
```

Table 1. Statistics of genome assemblies regarding to Taniguti et al. (2015) reference assembly.
| Genome statistics | Canu  | Flye  | SPAdes  | MaSuRCA | Unicycler |
|------------- | ------------- | ------------- | ------------- | ------------- | ------------- |
| Genome fraction (%) | 98.942 | 98.935 | 97.872 | 98.651 | 97.577 |
| Duplication ratio | 1.009 | 1.005 | 1.011 | 1.016 | 1.064 |
| Largest alignment | 2.007.994 | 2.009.134 | 728.570 | 1.981.789 | 757.444 |
| Total aligned length | 20.002.143 | 19.912.594 | 19.831.353 | 20.064.611 | 20.799.230 |
| NG50 | 869.800 | 868.706 | 250.961 | 945.175 | 369.707 | 
| Misassemblies |  27 | 24 | 23 | 31 | 16 | 
| Mismatches per 100 kbp|  12.37 | 13.5 | 8.79 | 12.36 | 21.22 | 
| Indels per 100 kbp|  90.05 | 62.48 | 29.84 | 34.36 | 39 | 
| N's per 100 kbp | 0 | 0| 0 | 0 | 0 | 

_**Analyzing some of these results!**_

1. Regarding **Genome fraction (%)** the assembly with the highest percentage of aligned bases in the reference genome is the **Canu** assembly.

>Genome fraction (%) is the percentage of aligned bases in the reference genome. A base in the reference genome is aligned if there is at least one contig with at least one alignment to this base. Contigs from repetitive regions may map to multiple places, and thus may be counted multiple times

2. The assembly with the lowest **duplication rate** is the **Flye** assembly, whilst hybrid assemblies show the highes values.

>Duplication ratio is the total number of aligned bases in the assembly divided by the total number of aligned bases in the reference genome (see Genome fraction (%) for the 'aligned base' definition). If the assembly contains many contigs that cover the same regions of the reference, its duplication ratio may be much larger than 1. This may occur due to overestimating repeat multiplicities and due to small overlaps between contigs, among other reasons.

3. The assembly with the **largest alignment** is the **Flye** assembly, and it is interesting to note that all of the hybrid assemblies have very low alignment when comparing to long-read assemblers, with exception, maybe, to MaSuRCA.

>Largest alignment is the length of the largest continuous alignment in the assembly. A value can be smaller than a value of largest contig if the largest contig is misassembled or partially unaligned.

4. The assembly with the highest alignment value to the reference was, surprisingly, the **Unicycler** assembly.
   
>Total aligned length is the total number of aligned bases in the assembly. A value is usually smaller than a value of total length because some of the contigs may be unaligned or partially unaligned.

5. The NG50 is a metric that relates to the reference, the highest value belongs to **MaSuRCA** assembly, but we will soon find out why is it such a larger number than for the rest.
   
>NG50 is the length for which the collection of all contigs of that length or longer covers at least half the reference genome.
This metric is computed only if the reference genome is provided.

6. The assembly with the fewest number of misassemblies is **Unicycler**.
   
>Misassemblies is the number of positions in the contigs (breakpoints) that satisfy one of the following criteria:
>the left flanking sequence aligns over 1 kbp away from the right flanking sequence on the reference;
>flanking sequences overlap on more than 1 kbp;
>flanking sequences align to different strands or different chromosomes;
>flanking sequences align on different reference genomes (MetaQUAST only).

7. The assembly which yielded the least number of mismatches is that from **SPAdes.** And it was also the one with less indels.

>Mismatches per 100 kbp is the average number of mismatches per 100,000 aligned bases in the assembly. True SNPs and sequencing errors are not distinguished and are counted equally.

What can we interpret from those results? Even though SPAdes was the software responsible for yielding the assembly with least mistmatches and indels, it produced poor alignments and the worst NG50 value. It appears that, regarding the reference, Canu and Flye were the best softwares for this data set, yielding very similar assemblies, even though Canu yielded a slightly higher NG50 value.

Analyzing the genomic statistics without a reference!

Table 2. Statistics of genome assemblies without reference generated by QUAST v5.0.2.
| Genome statistics | Canu  | Flye  | SPAdes  | MaSuRCA | Unicycler |
|------------- | ------------- | ------------- | ------------- | ------------- | ------------- |
| Contigs | 30 | 30 | 156 | 28 | 144 |
| Largest contig | 2.009.568 | 2.010.693 | 808.454 | 3.182.994 | 867.786 |
| Total length | 20.062.084 | 19.968.512 | 19.903.950 | 20.124.895 | 20.867.918 |
| N50 | 869.800 | 868.706 | 250.961 | 945.175 | 358.219 |
| GC (%) | 55.01 | 55.08 | 54.9 | 54.98 | 55.11 | 

_**Analyzing these results!**_

1. We can see that SPAdes and Unicycler yielded extremely fragmented assemblies, expressed by the number of contigs, while Canu, Flye and MaSuRCA yielded a number close to the reference genome.
2. The largest contig was produced by MaSuRCA, surpassing around 1 million base pairs from the largest contig in the reference.
3. Again, the N50 tell us the SPAdes and Unicycler assemblies are fragmented. The highest N50 was that from MaSuRCA, but that might not be necessarily good.
4. The GC content was around 55% for all the assemblies.

We assessed the completeness of these genomes by assessing their catalogue of single-copy orthologous conserved among members of basidiomycota group. We did that by using compleasm ```v.0.2.2``` but also BUSCO using ```basidiomycota_odb10``` database with the below example code:

```
compleasm run -a /home/pedro/assemblies/04B/assembly/canu/SSC04B_canu.fasta -o SSC04B_canu.compleasm -l basidiomycetes -t 10 -L /home/pedro/assemblies/basidiomycota_odb10/
```

>This will download the specified lineage (or automatically search for the best lineage with autolineage mode), align the protein sequences in the lineage file to the genome sequence with miniprot, and parse the miniprot alignment result to evaluate genome completeness.

Table 3. Genome completeness assessed through ```compleasm v.0.2.2```
| Genome statistics | Canu  | Flye  | SPAdes  | MaSuRCA | Unicycler |
|------------- | ------------- | ------------- | ------------- | ------------- | ------------- |
| Single-copy orthologs (%) | 99.66 | 99.77 | 99.72 | 98.92 | 94.22 |
| Duplicated (%) | 0 | 0 | 0 | 0.74 | 5.56 |
| Fragmented (%) | 0.17 | 0.17 | 0.23 | 0.17 | 0.17 |
| Missing (%) | 0.17 | 0.06 | 0.06 | 0.17 | 0.06 |

The assembly with the highest number of single-copy orthologs belongs to Flye. What is interesting is that both MaSuRCA and Unicycler have higher rates of duplicated genes in the genome. The most fragmented copies come from SPAdes assembler. The proportion of missing genes is quite similar in all of them. 

Just by looking at the completeness metrics and genome statistics, we decided to not go forward with assemblies belonging to Unicycler and SPAdes, especially because they are fragmented.

So, next, we wanted to take a look at how efficient the assemblers were in assembling T2T (telomere-to-telomere) contiguous sequences, since that is one of the goals of our paper. We verified the presence of telomeres in the contig larger than >50kpb (since we know there are no contigs in the reference with less base pairs than this threshold, the smaller one being the mitochondrial DNA). For that we used ```emboss v6.6.0.0``` conda package and the ```awk``` command to extract these sequences:

Get the contigs IDS bigger than 50kbp and print them:

```
infoseq -auto -noheading -only -name -length SSC04B_flye.fasta | sed -r 's/ +/\t/g'| awk '$2 >= 50000 {print "SSC04B_flye.fasta:"$1}' > SSC04B_flye.ctg.g50kbp.ids
```

Retrieve the sequences:

```
seqret @SSC04B_flye.ctg.g50kbp.ids SSC04B_flye.ctg.g50kbp.fasta
```

To scan for telomeric sequences We used tidk ```0.2.41``` package. We retrieved the canonical telomeric sequence of one of the contigs of _S. scitamineum_ reference from Taniguti et al. (2015): ```CTAACC``` and used the following command:

```
tidk search --string CTAACC --output SSC04B_canu.ctg.g50kbp.tidk.CTAACC --extension tsv --dir . SSC04B_canu.ctg.g50kbp.fasta
```

To represent the found repetitive sequences graphically in our internal analyses, we bowered the personalized Rcode from Prof. Diego Mauricio Riano Pachon from CENA entitled [plotTelomericRepeatPositions.R.](https://github.com/pedrofvilanova/sscitamineum_omics/blob/main/re-assemblies/plotTelomericRepeatPositions.R).

```
Rscript plotTelomericRepeatPositions.R SSC04B_flye.ctg.g50kbp.tidk.CTAACC_telomeric_repeat_windows.tsv
```

By looking at the comparison between Flye vs. Canu assemblies, we observeed that Flye assembled 22 telomeric regions, while Canu was able to assemble 46 telomeric regions, twice the number, and many of those telomeric regions are contigs T2T.

![telomeric_flye_canu](https://github.com/pedrofvilanova/sscitamineum_omics/assets/73193082/62bc2e22-d4ea-4cd2-b1b8-382afc7299f3)

Even though MaSuRCA assembled 28 contigs and have apparently good statistics, we chose to analyze it separately. It assembled 40 telomeric regions, but those regions are present in very small contigs and we can see in the first contig the presence of multiple telomeric regions, probably the reason why the contig is larger than the reference
![image](https://github.com/pedrofvilanova/sscitamineum_omics/assets/73193082/25884b63-74df-4b61-a126-36e04b918ed3)

Last, but not least, we graphically plot a comparative analysis between our reference and the assemblies. We did it using ```JupiterPlot```:

```
./jupiter t=5 m=100000 name=SSC04B_canu ref=/home/thais/Ssci_references/39B/NCBI_Ssci_genome.fa fa=/home/pedro/assemblies/04B/assembly/canu/SSC04B_canu.fasta ng=100 minBundleSize=5000
```

The output image shows that Flye and Canu assemblies are quite similar to our reference, be it in size or in collinear sequences, with few ribbons not aligning to the same chromosome in the reference, all of them in telomeric repetitive regions.

![compare_to_Ref](https://github.com/pedrofvilanova/sscitamineum_omics/assets/73193082/01496918-02e3-44f7-ac36-594c9e98f517)

When we looked at MaSuRCA assembly in comparison with the reference it became quite clear why the N50 is higher and the largest contig is 1 million base pairs longer than the reference contig. It seems that a whole contig actually became attached to the end of the first contig, which would explain the telomeric repeats in the middle of the contig as evidenced by the telomeric regions figure.

![SSC04B_masurca](https://github.com/pedrofvilanova/sscitamineum_omics/assets/73193082/00f85169-f117-4ebc-a3f1-0b0e94fbb0b7)

After amounting these evidences, we chose to eliminate MaSuRCA assembly to go forward.

We chose the best assembly based on:
1. Best completeness expressed by the number of single-copy orthologs in basidiomycota.
2. NG50 and N50 contiguous metrics.
3. Presence of telomere-to-telomere sequences.

_**Using the above criteria we elected the assembly produced by Canu as the best.**_ So we proceeded to testing polishing softwares.

## :dna: What about mitochondria?

We know for a fact that _S. scitamineum_ mitochondrion genome has **88.018** pb for the reference. In our assemblies, Canu was the only one to report the presence of a circular contig, quite bigger than the reference, but showing the "trim" warning:

>This is the non-redundant sequence for the circular molecule. So if you trimmed the contig to those coordinates, it should not have any self-similarity due to circularization on the ends.

# :paintbrush: Polishing the genome: Making it better 

Since we chose the assembly by Canu as the best one, I proceeded to test three polishing softwares to evaluate how much better the assembly would be. Those softwares were:
1. Medaka
2. Pilon
3. Racon

## :dna: Medaka: Oxford Nanopore consensus tool
The first one we tested was Medaka. According to the authors:

>medaka is a tool to create consensus sequences and variant calls from nanopore sequencing data. This task is performed using neural networks applied a pileup of individual sequencing reads against a draft assembly. It provides state-of-the-art results outperforming sequence-graph based methods and signal-based methods, whilst also being faster.

It is interesting to note that the authors also state two interesting points:

**1. Improved accuracy over graph-based methods (e.g. Racon).**

**2. 50X faster than Nanopolish (and can run on GPUs).**

We used ```medaka v.1.8.0 ```:

```
medaka_consensus -i /home/pedro/assemblies/04B/raw/nanopore/SSC04B_allreads_2023.fastq.gz -d /home/pedro/assemblies/04B/assembly/canu/SSC04B_canu.fasta  -o /home/pedro/assemblies/04B/assembly/canu/polishing/medaka-1x/ -t 12
```

## :dna: Racon: Oxford Nanopore consensus tool

The second software we tested was Racon. According to the authors:

>Racon is intended as a standalone consensus module to correct raw contigs generated by rapid assembly methods which do not include a consensus step. The goal of Racon is to generate genomic consensus which is of similar or better quality compared to the output generated by assembly methods which employ both error correction and consensus steps, while providing a speedup of several times compared to those methods. It supports data produced by both Pacific Biosciences and Oxford Nanopore Technologies.

We used ```Racon v1.5.0```. In order to use Racon, one needs to first map the sequencing reads to the assembly to be polished. You can use Racon with either ONT data or Illumina, but we chose to do it with ONT data. So we used ```minimap2 v. 2.26-r1175``` to map the ONT reads to the assembly

```
minimap2 -a -t 14 /home/pedro/assemblies/04B/assembly/canu/SSC04B_canu.fasta /home/pedro/2023_genomes_final/ssc_04_b_29_03_23/20230329_1512_MN32147_FAL62188_d457662b/fastq_04B/pass/SSC04B_allreads_porechop.fastq > reads_mapped.sam
```

Once mapped, we proceeded to actually using Racon:

```
racon /home/pedro/2023_genomes_final/ssc_04_b_29_03_23/20230329_1512_MN32147_FAL62188_d457662b/fastq_04B/pass/SSC04B_allreads_porechop.fastq reads_mapped.sam /home/pedro/assemblies/04B/assembly/canu/SSC04B_canu.fasta > SSC04B_canu_racon1x.fasta
```

## :dna: Pilon: Automated genome assembly improvement

One of the other polishing software was Pilon. According to the authors:

>Pilon requires as input a FASTA file of the genome along with one or more BAM files of reads aligned to the input FASTA file. Pilon uses read alignment analysis to identify inconsistencies between the input genome and the evidence in the reads. It then attempts to make improvements to the input genome, including:
>1. Single base differences
>2.Small indels
>3. Larger indel or block substitution events
>4. Gap filling
>5. Identification of local misassemblies, including optional opening of new gaps

To use Pilon it is of unparallel importance to map the reads, be it Nanopore or Illumina, to the assembly. We chose to polish the genome with Illumina, therefore we used ```bwa mem v. 0.7.17-r1188``` to the mapping step. 

First, we need to index the genome:

```
bwa index SSC04B_canu.fasta
```

Then the next step is mapping itself:

```
bwa mem -t 14  SSC04B_canu.fasta  /home/sporisor/dnaseq/illumina/Genomes_Illumina/NGS767_Claudia_Pedro-412581533/BCLConvert_03_16_2024_02_30_30Z-723878187/NGS767_2_SSC04B-ds.e41443545426483b9c820599b1897356/NGS767_2_SSC04B_S19_L001_R1_001.fastq.gz /home/sporisor/dnaseq/illumina/Genomes_Illumina/NGS767_Claudia_Pedro-412581533/BCLConvert_03_16_2024_02_30_30Z-723878187/NGS767_2_SSC04B-ds.e41443545426483b9c820599b1897356/NGS767_2_SSC04B_S19_L001_R2_001.fastq.gz > Illumina_vs_SSC04B_canu_medaka1x_01.sam
```

Then, we just need to convert the ```.sam``` file to ```.bam.```

```
samtools view -Sb Illumina_vs_SSC04B_canu_medaka1x_01.sam > Illumina_vs_SSC04B_canu_medaka1x_01.bam
```

Sort the ```.bam``` file

```
samtools sort â€“o Illumina_vs_SSC04B_canu_medaka1x_01.sorted.bam Illumina_vs_SSC04B_canu_medaka1x_01.bam
```

Index the sorted ```.bam``` file

```
samtools index Illumina_vs_SSC04B_canu_medaka1x_01.sorted.bam
```

Now, we can proceed to actually use Pilon. We used ```Pilon v. 1. 24```, available as a module on ```biotec02.esalq.usp.br```

```
pilon --genome SSC04B_canu.fasta --fix all --changes --tracks --bam Illumina_vs_SSC04B_canu_medaka1x_01.sorted.bam --output /home/sporisor/polishing/pilon
```

# :dna: Analyzing polishing results

After polishing the Canu assembly, it was possible to see that the polishing did not have any effect whatsoever on completeness, no matter the software or number of iterations. P.S: We only did more than on iteration with Pilon. We also did not use Pilon by itself. 

| Genome statistics | Medaka  | Medaka + Pilon 1x  | Medaka + Pilon 2x  | Racon |
|------------- | ------------- | ------------- | ------------- | ------------- |
| Single-copy orthologs (%) | 99.66 | 99.66 | 99.66 | 99.66 |
| Duplicated (%) | 0 | 0 | 0 | 0 | 
| Fragmented (%) | 0.17 | 0.17 | 0.17 | 0.17 | 
| Missing (%) | 0.17 | 0.17 | 0.17 | 0.17 | 

When we check QUAST statistics regarding the reference:

| Genome statistics | Medaka 1x  | Medaka + Pilon 1x  | Medaka + Pilon 2x | Racon |
|------------- | ------------- | ------------- | ------------- | ------------- |
| Genome fraction (%) | 98.937 | 98.937 | 98.937 | 98.96 | 
| Duplication ratio | 1.01 | 1.01 | 1.01 | 1.01 | 
| Largest alignment | 2.009.909 | 2.010.291 | 2.010.239 | 2.010.002 | 
| Total aligned length | 20.022.640 | 20.027.336 | 20.026.696 | 20.028.102 | 
| NG50 | 870.690 | 870.803 | 870.797 | 870.729 | 
| Misassemblies |  27 | 27 | 27 | 29 | 
| Mismatches per 100 kbp| 13.29 | 11.05 | 10.84 | 13.49 | 
| Indels per 100 kbp|  53.3 | 33.87 | 32.94 | 60.36 | 

Looking at this data, it appears each iteration of Pilon after Medaka had slightly better statistics regarding the reference, but it remains unclear where the plateau of these changes would be. 

# Gene annotation and variant calling

The pipelines related to gene annotation and variant calling can be viewed at Lucas Taniguti's GitHub page: https://github.com/lmtani/s-scitamineum-pipelines
